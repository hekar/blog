<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Markdown."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Python&#x27;s Yield Keyword | Hekar&#x27;s Log</title><meta property="og:image" content=""/><meta name="next-head-count" content="16"/><link rel="preload" href="/blog/_next/static/css/a39f38d88d9ad441c8d0.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/a39f38d88d9ad441c8d0.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/638ceea9d6aeb94de336.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/638ceea9d6aeb94de336.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-e4c796d2c240145f9837.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework-45e9b849801d11e9c054.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons-2d0244bebd598e26d2fd.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-5d758df2dffcf497d56f.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-841f7939ab4d644b6735.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/853-d37cfdc4604a543e18de.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-28b03ac8116d9c3cd2f6.js" as="script"/></head><body><div id="__next"><div class="min-h-screen"><div class="border-b bg-accent-1 border-accent-2"><div class="container mx-auto px-5"><div class="py-2 text-center text-sm">Created with<!-- --> <a href="https://github.com/vercel/next.js/tree/canary/examples/blog-starter-typescript" class="underline hover:text-success duration-200 transition-colors">Next.js</a>.</div></div></div><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/blog">Hekar&#x27;s Log.</a></h2><article class="mb-32"><div class="max-w-2xl mx-auto"><h1 class="text-6xl md:text-6xl lg:text-7xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-left">Python&#x27;s Yield Keyword</h1><div class="block mb-6"><div class="flex items-center"><div class="text-xl font-bold">Hekar Khani</div></div></div><div class="mb-6 text-lg"><time dateTime="2012-01-12">January	12, 2012</time></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__1x9gM"><p>One of my most missed features in Java is the yield keyword found in Python.</p>
<p>Instead of processing an entire a collection and returning it. The yield keyword, will automatically create a lazily loaded iterable out of a function. This removes a ton of boilerplate that one would otherwise need to create an iterable.</p>
<hr>
<p>The stack is saved and all the local state is the same, but the function does not need to process everything before it allows the for loop to continue. Instead, only the next value needs to be calculated.</p>
<p>Example:</p>
<pre><code>def fun():
  for i in range(0, 50000):
    print(i)
    yield i

for number in fun():
  print(number)
</code></pre>
<p>This would print:</p>
<pre><code>1
1
2
2
3
3
...etc
</code></pre>
<p>That is because we're basically calculating the value as we move on to process the next value.</p>
<p>Without using yield, one would do something like:</p>
<pre><code>def not_fun();
  results = []
  for i in range(0, 50000):
    print(i)
    results.append(i)
  return results

for number in not_fun():
  print(number)
</code></pre>
<p>This would print:</p>
<pre><code>1
2
3
4
5
6
...etc.
</code></pre>
<p>Yield can be invaluable when processing I/O intensive tasks that you want to perform sequentially. Instead of processing everything at once, you can process each item on as needed basis.</p>
</div></div></article></div></main></div><footer class="bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Python's Yield Keyword","date":"2012-01-12","slug":"2012-01-12-python-yield-keyword","content":"\u003cp\u003eOne of my most missed features in Java is the yield keyword found in Python.\u003c/p\u003e\n\u003cp\u003eInstead of processing an entire a collection and returning it. The yield keyword, will automatically create a lazily loaded iterable out of a function. This removes a ton of boilerplate that one would otherwise need to create an iterable.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eThe stack is saved and all the local state is the same, but the function does not need to process everything before it allows the for loop to continue. Instead, only the next value needs to be calculated.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef fun():\n  for i in range(0, 50000):\n    print(i)\n    yield i\n\nfor number in fun():\n  print(number)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis would print:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1\n1\n2\n2\n3\n3\n...etc\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat is because we're basically calculating the value as we move on to process the next value.\u003c/p\u003e\n\u003cp\u003eWithout using yield, one would do something like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef not_fun();\n  results = []\n  for i in range(0, 50000):\n    print(i)\n    results.append(i)\n  return results\n\nfor number in not_fun():\n  print(number)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis would print:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1\n2\n3\n4\n5\n6\n...etc.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYield can be invaluable when processing I/O intensive tasks that you want to perform sequentially. Instead of processing everything at once, you can process each item on as needed basis.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2012-01-12-python-yield-keyword"},"buildId":"mJbUB12BbsjDO8NNxYNxc","assetPrefix":"/blog","isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/blog/_next/static/chunks/webpack-e4c796d2c240145f9837.js" async=""></script><script src="/blog/_next/static/chunks/framework-45e9b849801d11e9c054.js" async=""></script><script src="/blog/_next/static/chunks/commons-2d0244bebd598e26d2fd.js" async=""></script><script src="/blog/_next/static/chunks/main-5d758df2dffcf497d56f.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-841f7939ab4d644b6735.js" async=""></script><script src="/blog/_next/static/chunks/853-d37cfdc4604a543e18de.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-28b03ac8116d9c3cd2f6.js" async=""></script><script src="/blog/_next/static/mJbUB12BbsjDO8NNxYNxc/_buildManifest.js" async=""></script><script src="/blog/_next/static/mJbUB12BbsjDO8NNxYNxc/_ssgManifest.js" async=""></script></body></html>