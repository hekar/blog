{"pageProps":{"post":{"title":"Python's Yield Keyword","date":"2012-01-12","slug":"2012-01-12-python-yield-keyword","content":"<p>One of my most missed features in Java is the yield keyword found in Python.</p>\n<p>Instead of processing an entire a collection and returning it. The yield keyword, will automatically create a lazily loaded iterable out of a function. This removes a ton of boilerplate that one would otherwise need to create an iterable.</p>\n<hr>\n<p>The stack is saved and all the local state is the same, but the function does not need to process everything before it allows the for loop to continue. Instead, only the next value needs to be calculated.</p>\n<p>Example:</p>\n<pre><code>def fun():\n  for i in range(0, 50000):\n    print(i)\n    yield i\n\nfor number in fun():\n  print(number)\n</code></pre>\n<p>This would print:</p>\n<pre><code>1\n1\n2\n2\n3\n3\n...etc\n</code></pre>\n<p>That is because we're basically calculating the value as we move on to process the next value.</p>\n<p>Without using yield, one would do something like:</p>\n<pre><code>def not_fun();\n  results = []\n  for i in range(0, 50000):\n    print(i)\n    results.append(i)\n  return results\n\nfor number in not_fun():\n  print(number)\n</code></pre>\n<p>This would print:</p>\n<pre><code>1\n2\n3\n4\n5\n6\n...etc.\n</code></pre>\n<p>Yield can be invaluable when processing I/O intensive tasks that you want to perform sequentially. Instead of processing everything at once, you can process each item on as needed basis.</p>\n"}},"__N_SSG":true}